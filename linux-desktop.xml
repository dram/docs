<?xml version="1.0" encoding="UTF-8" ?>

<book version="5.0"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink">
<info><title>Linux桌面应用</title>
  <author>
    <personname>王欣</personname>
    <email>dram.wang@gmail.com</email>
  </author>
<releaseinfo>draft r0.1, 2011-04-10</releaseinfo>
</info>

<dedication><title/>
  <blockquote><attribution>伊壁鸠鲁</attribution>
    <para>身体的健康和灵魂的平静是幸福的极致。</para>
  </blockquote>
</dedication>

<preface><title>前言</title>

<para>计算机作为信息化时代的重要工具，渗透到了生活的方方面面，甚至它已经超越一般意义上“工具”的概念，不再单单为我们所用，更是在悄然影响并引导着我们的生活方式。然而对于它，我们只是和对待其它普通工具一样，被动地接受工具的设计者和制造者所提供的功能和使用方式，没有意识到它对生活的种种影响，也没有主动地思考我们的生活需要什么。我们不再是工具的支配者，反而是被工具所支配。这是Douglas Rushkoff在Program or be Programmed一书中给予我们的警示。</para>
<para>就像随着交通、通信等技术的发展，我们虽然享受到了便利，但面对因为这些技术而不断加快的生活节奏却无能为力。所以发明技术的初衷或许是希望让人类生活更幸福，但技术的发展却不是个人所能把控的，所以必须对计算机和信息技术有深入的了解，才不至于处于被动。或许说得夸张了点，但至少，生活在这个时代，不管你是不是从事于IT行业，都需要对计算机技术有相当的了解。在我们日常生活中，很难找到像计算机这样功能如此复杂而又如此普及的工具。所以，了解它熟悉它不仅仅是可以提高工作、生活的效率，更是可以让自己从工具中解放出来，不再受制于它。</para>
<para>然而，现在的应用软件大多被一层层地包装，已经完全无法让用户全然理解，更多的只能是让用户望而生畏。对于一个软件，我们往往只希望用最短的时间学会必需的功能，而对于其它的功能，对于它的基本原理，不可能再去关心。我们只能被迫全然信任软件的设计者和他们所制定的使用手册。</para>
<para>计算机技术真的就只能这么复杂？软件将被设计得越来越傻瓜化，这是否是信息技术发展的必然趋势？计算机技术与其它技术相比的一个重要特点是它的门槛更低，不是任何人都可以造出汽车，但大多数人却都是可以制作出软件的。所以是否有一种途径可以让更多的人参与到信息革命中来？</para>
<para>商业的系统永远只会以利益为导向，不可能顾及这些。而开源运动由于其本身的开放性，是否可以带来一丝的希望？Linux作为开源世界的重要成员，这些年有了长足的发展，然而在桌面应用市场却迟迟未见扩张，其中的原因值得我们思考。是历史的兼容性问题？还是用户使用体验问题？还是有其它什么原因？Linux桌面应用该往怎样的方向发展？极力地去模仿Windows和Mac的形式和操作习惯是否可行？还是说能有一条更为理想的路？Linux有其自身的诸多特点，是否可以加以利用？</para>
<para>虽然现有的技术还不足以让每一个用户设计自己的软件，但用户可以根据自己的需求对不同组件进行定制和整合。本文就是以上述问题为引线，从Linux的高可定制性以及它的KISS<footnote><para>KISS是Keep It Simple and Stupid的缩写，详细说明可以查看维基百科：<link xlink:href="http://en.wikipedia.org/wiki/KISS_principle"/>。</para></footnote> 设计哲学出发，尝试搭建一个日常使用的桌面环境。桌面应用只是计算机应用的一小方面，计算机技术对生活有着更深层次的影响，但我们可以从桌面应用出发，思考我们对于计算机的需求。</para>
<para>另外，由于Linux在很多功能上都有较多的程序可供选择，所以这里的桌面环境必然是非常个人化的，希望读者更多的是从中得到一些思路，而不只是实际的方法。</para>
<sect1><title>内容组织</title>

<para>本文的大部分内容是自己这些年在对Linux桌面断断续续的使用中所积累的一些笔记和体会，一开始只是作为对自己知识的一个疏理。最终考虑用更为严肃的形式加以整理，这样可以和其他Linux使用者分享。如果有任何人能够从本书中找到一点两点对其有用的内容，那么我也就非常欣慰了。</para>
<para>对于个人笔记的整理，曾经尝试过很多的方式：博客、个人WIKI、思维导图等，但都不是非常理想，最终还是觉得以正式的文档甚至是书的形式来组织最能引起自己的认真对待。很多时候，形式是重要的，只有在正式的形式下，才能引导自己进行严肃的思考。</para>
<para>在文中会提出一些问题，大多也会给出我的理解。在思考这些问题时，我尽量不参考其它的资料和别人的观点，因为那些资料读者通过搜索引擎自然可以找到，这里更多的是我对自己的理解的直接表述，尽量不受其他观点的影响。但这样的一个后果是，可能很多想法会很不成熟，甚至有些是根本错误的，还望读者能够多多包涵。</para>
</sect1>
<sect1><title>面向的读者</title>

<para>本文主要面向的是对Linux系统以及Linux桌面应用己经有所了解的读者，比如对于发行版的概念，桌面环境与窗口管理器的关系等应该都已经有所了解。本文不会再对这些常用概念做额外的介绍。</para>
<para>由于Linux的普及程序依然不够，如果没有对Linux有一定了解可能在阅读本文时会有一定困难。但由于自身能力和经验的限制，无法对各类概念做简明的定义和说明，所以不能够面向更为广泛的读者。不过我会尽量在一些概念首次出现时添加外部链接，这样可以方便读者查找。</para>
</sect1>
<sect1><title>环境说明</title>

<para>本文的环境是在Windows下的VirtualBox搭建的，不过文中大部分的内容与是否运行于虚拟机下是无关的，所以全文不会提及与VirtualBox相关的内容，只在附录中专门对它的设置进行的介绍。</para>
<para>另外，这里使用的Linux发行版是CRUX，虽然不同发行版在某些方面相差较大，但对于桌面应用影响不大，所以在正文中也不会提及与CRUX配置相关的内容。</para>
</sect1>
<sect1><title>配置和代码</title>

<para>Linux桌面环境下必然会涉及到较多的配置，另外文中也提及了我自己写的一些小工具，所有这些相关的配置和代码都存放在<link xlink:href="https://github.com/dram/configs"/>。可以通过git工具进行同步，对于git的使用可以查看<link linkend="manage-configs">配置文件管理</link>一节。</para>
</sect1>
<sect1><title>更新</title>

<para>本文档会不定期进行更新，可以从<link xlink:href="https://github.com/dram/docs"/>中找到相关更新的细节，请注意查看。</para>
</sect1>
<sect1><title>意见反馈</title>

<para>由于经验有限，本文必然有很多不足，读者如有发现错误或者有待探讨的地方，还望指出，我的邮箱为dram.wang@gmail.com。</para>
</sect1>
</preface>

<chapter><title>操作系统</title>

<para>操作系统，作为对底层硬件的封装和抽象，为上层应用程序提供访问硬件资源的接口，这是内核的基本功能，从这一层意义来说，如果将计算机作为桌面应用的工具，用户基本上不需要关心操作系统层面的东西。</para>
<para>就比如线程，它究竟是在用户层还是在内核实现，这对于用户来说没有区别，甚至于应用程序是利用多线程还是多进程机制实现，用户也可以不关心。就像Google在宣传Chrome浏览器时，强调的一点是它的每一个标签页都是独用进程，所以其中任何一个页面崩溃都不会影响其它标签页。但这更多的只是对Firefox不稳定性的一个攻击，而不能说是一个优点，并且理想的程序就不应该让“不合法的页面内容导致页面崩溃”这一现象出现。所以对用户来说，如果不出错，两者的体验是完全相同的。但用户需要知道“多任务”这一概念，“单任务”和“多任务”将促成全然不同的事务组织方式 <footnote><para>当然，至于单任务和多任务，到底人脑更适合哪一种方式，这又是另一层面的问题了，至少，“多任务”在大部分情况下确实提高了工作效率。</para></footnote>。</para>
<para>另外，由于操作系统功能相当明确，所以理想情况下在系统稳定后是无需再做大幅更新的，Windows XP就是一个很好的例子，从2001年发布到现在将近10年，依然在大范围的使用。然而硬件和软件的更新换代是相互推动的，商业公司必须促使用户更新产品，以此才能获取利润。所以即使对于一个操作系统来说，Windows XP已经够用，Microsoft还是需要推出Windows 7，对于XP的支持最终还是要停止。这样的后果是，在越来越多的应用软件只对Windows 7支持后，用户不得不对操作系统进行更新，而这一更新，不是因为操作系统本身的新功能，而只是为了能够支持新的应用软件。所以微软在更新操作系统时，并在是仅仅更新内核，更是要更新桌面体验，以些来吸引用户。</para>
<para>这就扩大了操作系统的概念，除了内核外，还包含软件包管理系统、桌面环境和大量的基础程序等。这也是我们平时说的操作系统的概念，比如Windows和Mac。所以用户还是需要关心一些与操作系统相关的东西的，这样可以了解计算机软件的运行基础。这样的操作系统概念在Linux中对应的就是发行版<footnote><para>关于发行版的定义，可以查看这里：<link xlink:href="http://en.wikipedia.org/wiki/Linux_distribution"/>。</para></footnote>的概念。桌面环境将在下一章再作介绍，这里主要就Linux发行版以及软件包管理机制作一些讨论。</para>

<sect1><title>发行版</title>

<para>对于发行版，首先有必要考虑一个问题：为什么Linux有如此多的发行版？这或许正的Linux自由的体现，而同时也让我们看到了自由的代价。</para>
<para>用户的需求是多样的，这是必然。对于商业系统，会根据多种因素对用户进行归并、取舍，最终也只是维护少数几个版本，比如微软在Windows系统分为Desktop, Server, Mobile等版本。而在Linux中，用户除了有选择发行版的自由外，还有制作发行版的自由，而且制作的难度不是很高 <footnote><para>从某种意义上说，这可以用帕金森的鸡毛蒜皮定律或芝麻绿豆定律(Parkinson’s Law of Triviality)来解释。越是简单的，大家都了解的事，不同的意见也就越多。这个时候，自由有时就并非好事，自由之下意见不和可能就要导致各自为政，从而浪费了大量的资源。</para></footnote>，这可能是导致发行版本泛滥的一个主要原因。</para>
<para>虽然，很多时候，矛盾是不可调和的，就比如上面提到的桌面用户的需求和服务器用户的需求在很多方面必然是不同的。但人往往太容易陷入细节，太容易追求局部的、片面的完美。为了一些细小的分歧而将一个项目分支为两个项目。虽然对于各自项目来说，都实现了各自的需求，都达到某种层度上的完美，但从全局看，固定的资源，原本可以在同一个项目上发力，而现在却要分为两拨，其中必然有大量的重复劳动，是很大的损失，从这点上说又是完全不能称之为完美的。</para>
<para>那么对于普通用户来说，对于这个发行版，他最需要的是什么？这里我们只就桌面应用的用户进行讨论。如果除去不同发行版在不同软件上的选择，那么发行版需要提供的最重要的功能就是方便的包管理机制以及对应用软件的支持，因为用户需要使用的不是操作系统，而是运行于操作系统之上的应用软件。</para>
<para>可以说这两点也是各发行版之间主要的不同。在包管理方面，有dpkg, apt-get组合，有rpm, yum组合，还有pacman, AUR组合，还有emerge, portage组合等等，它们在功能上很多是相似的，都是对程序文件的组织，对依赖关系的处理。但在设计理念和使用方式上，却又有着很大的不同。附录中对Fedora的RPM及YUM工具作了简单介绍，可以作为参考。</para>
<para>包管理是为支持应用软件而服务的，最终是要提供用户方便的安装和更新软件的方式。所以对于用户来说，选择发行版本，最为重要的是看它对软件的管理方式。当然，在选择时还需要考虑其它一些因素，比如发行版的用户定位，用户群的大小等。下面主要就软件管理机制方面进行讨论，以此选择合适的发行版。</para>
</sect1>
<sect1><title>软件管理</title>

<para>软件管理，主要就是将程序文件组织在文件系统中，并对其进行统一管理，方便安装、卸载和升级。对于用户来说，只要需要使用的软件能够装上，能够使用，以后能够升级，对系统以及其它软件没有影响就可以了。但就是这么简单的需求，要实现起来也并不容易。特别是对于Linux来说，而很大一个原因还是因为自由。</para>
<para>以Windows为例，由于Windows的所有底层接口都由微软一家设计和维护，所以只要微软想让接口保持稳定，可以比较容易实现，甚至在XP和Win7跨度那么大的两个版本，很多二进制程序依然可以同时在两个系统中安装运行。而在Linux中，像操作系统接口、C语言库、X Window、图形控件等等，不同组件由不同组织开发，各自发行版本，再经过发行版选择组装。有些发行版以稳定性为中心，使用较老版本，另一些软件追求更多、更新的功能，使用较新版本。这就导致一个发行版的二进制程序很可能无法在另一个版本中运行。Android就是因为各版本间接口的不稳定而遭至骂声一片。</para>
<para>这还只是发行版层面的兼容性问题。更为麻烦的是，不同的应用程序开发者，对于基础库选择的趋向也是不同的。比如软件A和B都依赖于基础程序库L，A开发较早，依赖于 α 版本的L库，B依赖于 β 版本。由于程序库从 α 到 β 版本有重大更新，L库的开发者针对 β 版本放弃了向下兼容。那么，如果用户同时需要使用软件A和B，此时应该怎么处理呢？</para>
<para>Windows的处理方法是，软件A和B都将程序库L包含在自身的目录中，这样就避免了冲突。在Windows下这是可行的，因为绝不部分底层库由微软控制，已经保证了它的兼容性，而其它的一些第三方库只占少数。</para>
<para>而在Linux中，底层库也存在兼容性问题，而对它的处理就不能像Windows那样让各应用程序自己维护了，而只能是让不同应用程序共享底层程序库。因为底层库被使用的频率太高，很多库的体积又很大，如果各自维护，势必程序体积的增大，这样就会增加磁盘占用，降低程序加载速度，增大内存的使用。所以Linux的处理很可能是放弃软件A，或者等A更新后再加入软件B的支持。对虽然满足了同时需要软件A和B的用户的需求，但却迫使用户对软件进行升级。对于这一点，BSD相对来说好一点，它每一次发布的版本中包含内核以及应用层的一些基础库，这样在一定程度上保证的接口的稳定性。但这并没有包含开发桌面应用所需要的接口，所以对于桌面应用还是不够。</para>
<para>以上是基础库API及ABI接口层面导致的兼容性问题，从而让用户的应用程序版本选择上失去了一定的自由。而在各一方面，各个发行版自身对于底层接口稳定性的忽视也是导致这一问题的重要原因。</para>
<para>由于Linux上的应用程序一般为开源程序，可以非常方便的进行重新编译打包，所以二进制包一般由各发行版各自维护，而不是由软件设计者维护。再是在Linux中，大部分包管理工具都包含有网络下载更新功能，可以方便地对整个系统进行更新，这也致使大部分Linux发行版都会对软件包进行频繁更新，比如现在很多的都是六月一个新版本。这在一定程度上给用户造成了困扰。因为升级是需要花费人力成本的，而且还要考虑兼容性问题。并非所有用户都希望使用最新的软件。可能他只是需要对其中一两个应用软件更新，但由于这些应用软件的二进制包由发行版维护，而它们依赖于新的底层库，所以用户必须对整个系统进行更新才能安装使用这些软件的新版本。当然还是可以自行编译代码的，但这对于一个普通桌面用户来说，是要求太高了。给予用户选择是否对软件进行更新的自由，是对稳定性的一个重要保证，但在现有Linux发行版本中，很难找到比较理想的选择。用户只能寄希望于系统的更新不会带来什么麻烦，但这往往是不现实的。</para>
<para>当然，追求稳定的发行版是有的，比如RHEL, Debian stable等，但它们的稳定策略是针对整体系统而言，并没有对程序库和应用程序作区分，本质上它们是针对于服务器用户的。如果需要在这些系统中使用较新的应用程序也是复杂的。所以个人觉得现在Linux发行版的一个重要问题是，对库程序和应用程序在升级处理上没有做很好的区分。对于一个桌面应用为主的系统来说，库应该是相对稳定的，而应用程序应该是包含多个可用版本，供用户选择，一样可以在一定程度上避免了不同应用程序之间的冲突。</para>
<para>比较接近这一思路的是MEPIS发行版，它底层基于Debian stable，这样保证了系统接口的相对稳定性，而桌面应用程序版本则比较新。但对于需要较新的应用程序的界定也是困难的，不同的用户会有不同的需求。在满足不同用户需求上，Gentoo更为理想，它给予用户极大的自由，用户可以根据自身需要为不同软件选择不同版本。Gentoo将软件分为稳定(stable)和测试(testing)两个分支，与其它发行版不同的是，由于Gentoo的包管理机制是基于源码的，所以完全可以在stable分支的系统中针对个别软件使用testing分支的版本，这就允许用户在大部分包相对稳定的基础上，依然可以让少部分包保持较新，通过stable分支构建基本系统，而应用程序更为的是使用testing分支。而在二进制发行版本中，往往没有选择应用程序版本的自由。只是对于一个桌面系统来说，Gentoo门槛太高了。</para>
<para>对于一个系统来说，一个用户的需求是基本确定的，但要满足1万，1百万用户的需求，就不是那么容易了。不同发行版通过事先设想用户的需求来选择软件以及版本，而Gentoo通过给予用户选择的自由，让用户自己来搭建满足自己需求的系统。</para>
<para>希望在Linux各主要的底层库和桌面应用程序趋于稳定之后，各发行版的区别将逐渐淡化，这样在软件管理方式上也可能出现统一。Linux Standard Base(<link xlink:href="http://www.linuxbase.org"/>)标准正是在尝试对Linux应用的底层库接口制定标准。而PackageKit(<link xlink:href="http://www.packagekit.org/"/>则是希望对各发行版的包管理机制在图形界面上进行统一。</para>
<para>接下来，进入实战阶段，主要说明Linux发行版的安装以及基础功能配置的问题。</para>
</sect1>
<sect1><title>安装</title>

<para>对于一个操作系统的安装，并不需要每个用户都能够掌握，但也不能因此而忽略了它的用户体验，就比如Gentoo，虽然在它的安装过程中给予了用户极大的自由，同时也让用户对于Linux操作系统的组织有了一个较深的认识，但还是会因为没有较为简便的安装方式而将很多用户拒之门外。而相对来说，其它很多发行版，比如Fedora等，由于采用了图形化的安装界面，有较为丰富的提示和说明，减小了初次使用Linux系统的用户的障碍。</para>
<para>传统上，操作系统一般都是安装在硬盘中，但现在已经出现了越来越多的形式，比如LiveCD，U盘等。对于像网络设备等功能相对固定的系统更多的采用CF卡等只读媒介来存放系统，而对于桌面应用来说，虽然网络操作系统已经出现，将所有数据存储在网络上已经成为可能<footnote><para>Google的Chrome OS就是这样一种尝试，整个操作系统的唯一桌面应用软件就只有浏览器，所有其它应用都用网络服务代替。</para></footnote>，但大多还是以硬盘方式存储。</para>
<para>虽然不同发行版在安装上有不同处理，但最终完成的任务是相似的：磁盘分区、设置时间时区和语言、拷贝文件、安装系统引导程序、创建用户、系统自启动服务选择、网络设置等。下面对其中一些操作作简要说明，方便用户了解Linux系统的一些基础功能。</para>

<sect2><title>磁盘分区</title>

<para>针对不同的应用，会需要不同的磁盘分区方式，比如服务器可能就需要对日志存放进行单独分区，避免因为日志过大而影响服务的正常运行。而对于桌面应用来说，可能需要将数据文件存放进行单独分区，这样可以方便以后系统升级。</para>
<para>而分区的策略也会受到文件系统组织的影响。相对于Windows分盘形式来说，Linux系统的整体树型结构更为自由，可以对任何一个结点进行单独分区，不同分区可以针对存放的内容采用不同的文件系统。当然，这些更多的是出于性能上的考虑，而对于桌面应用影响不大。</para>
<para>在命令行下，分区一般通过<command>fdisk</command>或<command>cfdisk</command>进行，现在也出现了一些图形化的分区工具，比如GParted(<link xlink:href="http://gparted.sourceforge.net/"/>等。</para>
<para>在分区之后就需要考虑对各分区选择不同的文件系统了。比如传统的ext2, ext3，以及新近的ext4, btrfs等，对于这些文件系统的说明，可以查看这篇文章：<link xlink:href="http://linuxtweaks.wordpress.com/2010/04/23/which-linux-filesystem-to-choose/"/>。</para>

</sect2>
<sect2><title>创建用户</title>

<para>Linux基于UNIX设计，所以从一开始对多用户就有较好的支持。不过对于桌面系统来说，多用户并非必需，但通过区分超级用户和普通用户，还是可以增强系统的稳定性的。所以在Linux桌面系统中，一般不建议使用root作为日常使用的用户。</para>
<para>在桌面应用中，用户概念会同时结合用户组概念在文件权限，资源访问权限、操作权限等方面有所体现。比如如果需要使用声卡，则应该将用户加入<literal>audio</literal>组，可以通过<literal>gpasswd -a username audio</literal>命令或者直接修改<literal>/etc/group</literal>文件进行添加。</para>
<para>通过<literal>useradd -m username</literal>命令可以创建普通用户，<literal>passwd username</literal>可以修改该用户的密码。</para>
<para>另外，如果觉得每次在需要root权限时都要调用<literal>su</literal>并输密码比较繁锁，可以使用<literal>sudo</literal>命令。先调用<literal>visudo</literal>，在sudo配置文件中添加下面的内容，以后只要在需要管理员权限的命令前加上<literal>sudo</literal>就能以管理员权限运行该命令。<literal>sudo su -</literal>可以不必输入密码以root权限运行SHELL。</para>
<screen>username    ALL=(ALL)       NOPASSWD: ALL</screen>
</sect2>
<sect2><title>系统服务</title>

<para>在Linux系统中，有一个runlevel<footnote><para>关于runlevel的说明，可以查看这里：<link xlink:href="http://en.wikipedia.org/wiki/Runlevel"/></para></footnote>概念，用于指定用户希望以什么形式运行系统，对于桌面应用来说，一般会选择 3 或 5 ，分别指多用户终端环境和多用户桌面环境。而实际两者的区别不大，只是初始启动的服务有所不同。这些都在init系统中指定。对于init系统的维护，不同发行版有不同的工具，Feodra中使用的是<literal>chkconfig</literal>，Gentoo中使用的是<literal>eselect rc</literal>，但最终实现的动作是相似的。关于这一方面的介绍，可以查看wikipedia的说明：<link xlink:href="http://en.wikipedia.org/wiki/Init"/>。</para>
</sect2>
<sect2><title>网络</title>

<para>各发行版本在网络启动脚本上的设置都有所不同，但最终调用的命令都是相似的。通过<literal>ifconfig</literal>或者<literal>ip link</literal>命令设置静态网卡地址，而对于DHCP的支持则通过<literal>dhcpcd</literal>命令实现。DNS的设置存放在<literal>/etc/resolv.conf</literal>文件中。<literal>/etc/hosts</literal>文件中存放静态IP与域名绑定。</para>
</sect2>
<sect2><title>时间设置</title>

<para>对于时间的调整主要包括时区和时间的设置。时区的配置文件是<literal>/etc/localtime</literal>，从<literal>/usr/share/zoneinfo/</literal>中拷贝相应时区的文件到<literal>/etc/localtime</literal>即可完成对时区的修改。</para>
<para>设置系统时间可以通过<literal>date</literal>命令完成，格式为：<literal>date MMDDhhmmCCYY</literal>。M为月，D为日，h为时，m为分，CCYY为年。当然也可以使用ntp进行同步。</para>
<para>通过<literal>date</literal>命令设置的其实是系统的时间，并没有同步到物理时钟，通过<literal>/sbin/hwclock --systohc</literal>进行同步，但各发行版一般都会在系统关机脚本中加入物理时钟自动同步功能。</para>
</sect2>
</sect1>
<sect1><title>优化配置</title>

<para>以下再罗列一些对系统的配置和优化，供读者参考。</para>
<sect2><title>系统启动</title>

<para>对于系统启动速度的优化，主要需要从两方面着手。一是内核定制，删去不必要的驱动，将必需的驱动直接整合到内核文件而不是以模块方式编译。再是调整系统启动服务，删去不必要的服务。</para>
</sect2>
<sect2><title>虚拟磁盘</title>

<para>对于现在的计算机来说，磁盘IO依然是一个很大的瓶颈 <footnote><para>希望固态硬盘(SSD)的普及可以对这一现状有所改观。</para></footnote>，所以对一些频繁读写而又不需要保存的文件，如果将它们转移到内存中，应该可以极大地提高系统性能。以下就是对<literal>/tmp</literal>目录以及Firefox的cache目录进行的处理。</para>
<variablelist>
<varlistentry>
<term>
<literal>/tmp/</literal>目录
</term>
<listitem>
<para>
在<literal>/etc/fstab</literal>中添加<literal>tmpfs /tmp tmpfs size=300m 0 0</literal>，可以将<literal>/tmp/</literal>目录挂载为tmpfs文件系统，也就是使用内存存储文件。其中size是可选的，表示最大限值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Firefox Cache
</term>
<listitem>
<para>
挂载Firefox缓存到共享内存目录<footnote><para>这一优化对Firefox的响应速度会有较大提升，在 <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://wiki.archlinux.org/index.php/Speed-up_Firefox_using_tmpfs">http://wiki.archlinux.org/index.php/Speed-up_Firefox_using_tmpfs</link> 中有详细的介绍。</para></footnote>。方法是在<literal>about:config</literal>配置页面添加<literal>browser.cache.disk.parent_directory</literal>参数，值设置为<literal>/dev/shm/firefox-cache</literal>，再通过<literal>install -dm700 /dev/shm/firefox-cache</literal>新建该目录。
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>
</chapter>

<chapter><title>桌面环境</title>

<para>桌面环境是桌面应用中不可或缺的一部分。按功能划分，主要包括：窗口管理器(window manager)、任务栏(taskbar)、系统托盘(system tray)、桌面(desktop)等。</para>
<para>Linux下可以直接使用GNOME, KDE或XFCE等系统直接得到桌面环境的所有功能。而另一种方式是分别对各个组件进行选择，拼装成满足自身需求的桌面环境，这是KISS设计哲学很好的体现。其实对于GNOME, KDE和XFCE来说，它们对于这些功能也是通过不同程序实现的，只是这些程序的界面和操作的一致性较高，耦合性较大。</para>
<para>这些不同功能的程序能够很好的协调工作，主要得益于X Window标准化的接口。比如EWMH <footnote><para>EWMH标准由X Desktop Group制定，详细信息可以查看：http://standards.freedesktop.org/wm-spec/wm-spec-latest.html。</para></footnote>标准规定了窗口管理器的一些接口，这样不同窗口管理器虽然可能有全然不同的窗口组织策略，但处理机制是相同的，这就允许其它程序独立于窗口管理器直接对窗口进行处理。其它标准还有System Tray Protocol Specification, XEmbed Protocol Specification等等，可以在http://standards.freedesktop.org/查看更多的Linux下桌面应用相关标准。</para>
<para>下面主要介绍如何通过整合Openbox, tint2, xchainkeys等程序搭建一个轻量级的桌面环境。相关的配置文件和脚本先在这里列出，读者可以作为参考：</para>
<variablelist xml:id="wm-config-files">
<varlistentry><term>X Window启动脚本</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.xinitrc"/></para></listitem>
</varlistentry>
<varlistentry><term>Openbox启动脚本</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.config/openbox/autostart.sh"/></para></listitem>
</varlistentry>
<varlistentry><term>Openbox样式</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/tree/master/.themes"/></para></listitem>
</varlistentry>
<varlistentry><term>xchainkeys快捷键配置</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.config/xchainkeys/xchainkeys.conf"/></para></listitem>
</varlistentry>
<varlistentry><term>窗口控制辅助脚本</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/bin/wm-assist.py"/></para></listitem>
</varlistentry>
<varlistentry><term>tint2任务栏程序配置</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.config/tint2/tint2rc"/></para></listitem>
</varlistentry>
<varlistentry><term>fontconfig配置</term>
<listitem><para><link xlink:href="https://github.com/dram/dram-configs/blob/master/.fonts.conf"/></para></listitem>
</varlistentry>
</variablelist>
<sect1><title>窗口管理器</title>

<para>窗口管理器的主要作用是管理窗口的摆放，显示标题栏以及对窗口边框的修饰，还有对常用窗口操作的支持，如：最大化、最小化、窗口移动、改变窗口大小等。另外为方便键盘操作，窗口管理器一般还会提供快捷键设置的功能。</para>
<para>关于窗口的放置策略，有两种比较流行的方式，一种是层叠，另一种是平铺<footnote><para>相对来说，层叠的放置策略比较常见，对于平铺窗口放罟策略的介绍，可以查看： <link xlink:href="http://en.wikipedia.org/wiki/Tiling_window_manager"></link>。</para></footnote>。平铺可能对于大屏幕比较合适，这里还是选择传统的层叠式的窗口管理器。</para>
<para>另外还需要考虑窗口操作驱动方式的问题，可选的是计算机主要的两个输入接口：键盘和鼠标。两种方式各有利弊，鼠标操作非常直观，但双手更多的是停放在键盘上，这样会导致手在鼠标和键盘间频繁切换；而使用键盘控制窗口虽然比较快捷，但需要有一个适应的过程，需要在一段时间之后，才能将按键序列变成下意识的动作。这里主要是以介绍键盘操作为主。</para>
<para>对于用户来说，由于会对窗口进行大量的操作，所以窗口管理器的行为必须是直观的，同时为适应不同用户的需求，需要具备一定的可定制性。这里选择使用Openbox，它对于上述功能有比较好的支持，同时本身体积比较小巧，适合与其它程序整合使用。</para>
<para>Openbox配置文件是XML格式，可以直接修改，也可以使用图形化配置工具obconf修改配置，文件为<literal>$HOME/.config/openbox/rc.xml</literal>。下面主要来介绍与窗口管理器相关的一些配置。</para>
<sect2><title>虚拟桌面</title>

<para>关于虚拟桌面的概念，详细的可以查看：<link xlink:href="http://en.wikipedia.org/wiki/Virtual_desktop"/>。简单说来就是可以将开启的窗口分发到不同桌面从而更便于管理。</para>
<para>在Openbox中可以通过<literal>Ctrl+Alt+方向键</literal>或者<literal>Alt+鼠标滚轮</literal>进行虚拟桌面切换。移动窗口到桌面边缘可以将窗口移入另一个桌面，<literal>Shift+Alt+方向键</literal>也能完成同样的功能。</para>
</sect2>
<sect2><title>快捷键</title>

<para>上面已经提及，这里希望尽可能使用键盘完成常用的窗口操作以及其它一些桌面应用功能，虽然Openbox自带有快捷键设置功能，但并不支持chained key bindings功能<footnote><para>chained key bindings是指可以将多个键盘点击动作做为一个事作，将动作绑定到这一按键序列中，这样可以方便的快捷键进行分类设置，同时有效避免了因为首字母相同而引起的冲突。更为详细的说明可以查看xchainkeys的项目网站： <link xlink:href="http://code.google.com/p/xchainkeys/"/>。</para></footnote>，所以这里使用xchainkeys程序完成主要功能的快捷键设置，而对于一些只能由Openbox提供的功能，则依然使用Openbox的快捷键设置。</para>
<para>关于xchainkeys的使用，可以参考这里的<link linkend="wm-config-files">配置</link>。在配置中可能需要用到各个键盘按键的键名，可以通过下面的命令查看：</para>
<screen>xev | grep keycode</screen>
<para>另外，如果需要对特定按键进行交换或设置，可以使用xmodmap命令。比如下面的命令将替换菜单键为Win键，其中<literal>135</literal>是菜单键的keycode，不同键盘可能不同，具体可以通过上面的<command>xev</command>命令查看。</para>
<screen>xmodmap -e "keycode 135 = Super_R"</screen>
</sect2>
<sect2><title>窗口操作</title>

<para>虽然Openbox自身已经支持大量的窗口操作，并可以将这些动作设置为相应快捷键或鼠标动作。但其扩展性不好，不能支持一些更为复杂的窗口动作。所以这里基于EWMH标准编写了一个脚本程序对窗口进行控制，再利用xchainkeys捕捉键盘事件绑定到相应动作。通过外部脚本控制的另一个好处是，该脚本不受Openbox限制，也可以在其它窗口管理器中使用。完整的脚本可以查看： <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/dram/configs/blob/master/bin/wm-assist.py">https://github.com/dram/configs/blob/master/bin/wm-assist.py</link>。</para>
<para><literal>wm-assist.py</literal>脚本基于python-xlib实现，参考了wmctrl程序，其中除了实现基本的窗口操作外，还实现了其它一些功能，会在后面再作介绍。该脚本是一daemon程序，通过pipe接口接受外部命令，在xchainkeys的<link linkend="wm-config-files">配置文件</link>中可以查看到具体的命令格式。以下对在<command>wm-assist.py</command>中与窗口操作相关的几个动作加以说明：</para>
<variablelist>
  <varlistentry><term><literal>MOVE</literal></term>
    <listitem><para>相对于当前位置对窗口进行移动。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>RESIZE</literal></term>
    <listitem><para>改变当前窗口大小。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>CENTER</literal></term>
    <listitem><para>将当前窗口移至屏幕正中。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>CLOSE</literal></term>
    <listitem><para>关闭当前窗口。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>MAXIMIZE</literal></term>
    <listitem><para>最大化当前窗口。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>JOE</literal></term>
    <listitem><para>提升指定窗口或启用程序，关于这个动作的详细说明将在“程序启动”一节再作介绍。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>ALL</literal></term>
    <listitem><para>将浏览器、终端、编辑器依次排列，再次调用会将这些窗口恢复回原先的位置，主要是在需要同时查看多个窗口内容时使用。</para></listitem>
  </varlistentry>
</variablelist>
<para>另外，虽然这里以键盘操作为主，但对于一些操作来说，鼠标可能更为方便，下面再介绍几个键盘与鼠标相结合的快捷操作方式：</para>
<variablelist>
  <varlistentry><term><literal>Alt + 左键拖动</literal></term>
    <listitem><para>移动窗口。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>Alt + 右键拖动</literal></term>
    <listitem><para>更改窗口大小。</para></listitem>
  </varlistentry>
  <varlistentry><term><literal>Alt + 滚轮</literal></term>
    <listitem><para>切换虚拟桌面，这个前面已经提到。</para></listitem>
  </varlistentry>
</variablelist>
</sect2>
<sect2><title>样式</title>

<para>大多数窗口管理器在处理窗口的修饰时，为了方便用户自定义，都采用样式的形式处理，在 <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://box-look.org">http://box-look.org</link> 中可以找到大量的Openbox的样式。Openbox样式是一个文本描述文件，可以很方便地进行调整。这里使用的样式是基于Moka和1977 Openbox这两个样式调整的。</para>
<para>Openbox样式只是对窗口修饰的调整，程序自身的样式并没有改变。如果是GTK程序，可以通过<literal>gtk-chtheme</literal>程序进行调整。<literal>gtk2-engines</literal>软件包中包含很多GTK样式，更多样式可以在 <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gnome-look.org">http://gnome-look.org</link> 中找到。</para>
</sect2>
</sect1>
<sect1><title>桌面</title>

<para>在Windows中，桌面往往会放置常用程序的快捷方式以及最近需要访问的文件，而Linux的桌面环境常常会看到只显示一张背景图片，或者显示一些系统当前的资源占用状态。而且，多数窗口管理器都不带有桌面背景设置功能，需要借由其它程序实现。</para>
<para>Openbox也不例外，这里通过<literal>feh</literal><indexterm><primary>feh</primary></indexterm>命令对桌面背景进行设置。利用feh的<literal>--bg-tile</literal>,<literal>--bg-center</literal>,<literal>--bg-scale</literal>或<literal>--bg-seamless</literal>参数设置背景之后，feh会生成<literal>$HOME/.fehbg</literal>文件，下次如果需要设置同样的背景，只需要运行<literal>source $HOME/.fehbg</literal>即可，随后将看到，可以把这一命令放入Openbox自启动程序脚本中，从而在每次启动X Window时对桌面背景进行自动设置。</para>
<para>这里没有在桌面添加常用程序的快捷启动，而是通过其它形式加以代替，将在下面介绍。</para>
</sect1>
<sect1><title>程序启动</title>

<sect2><title>手工启动</title>

<para>对于安装在系统中的程序，需要有一个入口可以让用户启动这些程序，在Windows中一般是使用开始菜单或者桌面的快捷方式。菜单是比较详细的罗列，而桌面快捷方式则是便于启动常用的程序。</para>
<para>下面简要说明这里在处理程序启动问题时使用的几种方式。</para>
<para>首先是采用快捷键的方式，上面已经提到了xchainkeys工具，可以通过它来设置快捷键来直接启动相应程序。另外，在<literal>wm-assist.py</literal>还实现了<literal>jump-or-exec</literal>功能<footnote><para>jump-or-exec功能最初源自于Sawfish的jump-or-exec插件，相对于传统的Alt-Tab来说，这个功能更加方便，更为详细的介绍可以查看pluskid关于它的说明： <link xlink:href="http://lifegoo.pluskid.org/wiki/JumpOrExec.html"/>。</para></footnote>，该功能可以在指定程序没有启动时启动该程序，而在程序已经被开启时将该程序窗口提到最上层。</para>
<para>再一种方式是使用“运行”窗口，类似于Windows中按下Win+R键所弹出的窗口，在Linux中对应的程序是gmrun，它可以利用Tab键对命令进行补全。另外也可以使用跨平台工具Launchy，可以获得同样的功能。</para>
<para>最后再来介绍菜单方式，与配置文件一样，Openbox的菜单也是XML格式的，可以直接编辑，也可以通过menumaker程序自动生成，menumaker会自动检测当前系统所安装的程序，比如它会对<literal>/usr/share/applications</literal>目录下的<literal>.desktop</literal><footnote><para>desktop文件内容格式遵循Desktop Entry Specification标准，该标准的内容可以查看： <link xlink:href="http://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html"/>。</para></footnote>文件进行分析。</para>
</sect2>
<sect2><title>自启动</title>

<para>对于Openbox来说，有两处地方可以设置在启动X Window时需要自启动的程序。分别是自身的<literal>$HOME/.config/openbox/autostart.sh</literal>和<literal>/etc/xdg/openbox/autostart.sh</literal>这两个脚本，以及XDG标准规定的<literal>~/.config/autostart/</literal>和<literal>/etc/xdg/autostart/</literal>目录。</para>
<para>HOME目录中的<literal>autostart.sh</literal>优先级高于<literal>/etc/xdg/openbox/autostart.sh</literal>。<literal>$HOME/.config/autostart</literal>目录下的文件优先级高于<literal>/etc/xdg/autostart/</literal>下的同名文件 。</para>
<para>XDG标准的规定并不是强制性的，可以由窗口管理器决定是否需要运行该目录下的程序。在Openbox中是在<literal>autostart.sh</literal>脚本中进行的处理。</para>
<para>更为详细的说明可以查看<link xlink:href="http://openbox.org/wiki/Help:Autostart"/>还有<link xlink:href="http://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html"/>。</para>
</sect2>
</sect1>
<sect1><title>任务栏</title>

<para>与Windows一样，Linux中的任务栏程序一般会实现两个功能：提供窗口列表的显示和切换，以及systray显示功能。</para>
<para>Linux中可供选择的任务栏程序非常多，这里选择使用tint2，它包含了上述两项功能，相关设置可以参考这里的<link linkend="wm-config-files">配置文件</link> 。另外，如果需要单独的systray功能，可以使用stalonetray程序。</para>
</sect1>
<sect1><title>其它设置</title>

<sect2><title>复制粘贴</title>

<para>在X11窗口系统中，一般有两种复制粘贴方式，一种与Windows相似，通过各个程序菜单中的复制粘贴项或是使用与其相关连的快捷键。而另一种方式是通过鼠标选中文本进行复制，再利用鼠标中键或者SHIFT+INSERT进行粘贴。</para>
<para>第二种方式SELECTION方式，需要注意的是，鼠标的点击动作会清空SELECTION，所以如果希望将一个窗口的内容复制到另一窗口，必须保证在选中文本之后不能再点击鼠标左键。</para>
<para>但两种方式是不能互操作的，比如使用“复制”菜单项进行复制的内容不能通过鼠标中键进行粘贴。可以通过autocutsel工具对它们进行同步，将下面程序加入到自启动脚本中即可：</para>
<screen>autocutsel &amp;
autocutsel -selection PRIMARY &amp;</screen>
</sect2>
<sect2><title>字体</title>

<para>X Window的字体主要是通过libXft处理，而它又基于fontconfig和freetype，fontconfig可以在<literal>$HOME/.fonts.conf</literal>文件中对其进行配置，比如字体选择、AA开关等。对于libXft可以在<literal>$HOME/.Xdefaults</literal>进行配置，示例如下：</para>
<screen>Xft.dpi:       96
Xft.antialias: true
Xft.rgba:      rgb
Xft.hinting:   true
Xft.hintstyle: hintslight
Xft.lcdfilter: lcddefault</screen>
<para>现在大部分GTK程序都使用cairo渲染字体，cairo在1.10.0版本之后，加入了对lcdfilter的支持，这样在使用LCD显示屏时开启lcdfilter可以得到更为理想的字体显示效果。</para>
<para>以上只是对字体渲染的设置，对于中文用户来说，还需要进行默认中文字体的设置，这个设置由fontconfig处理，在<literal>$HOME/.fonts.conf</literal>配置文件中。可以在该文件中对sans, serif, monospace设置默认中文字体，详细方式参考<link linkend="wm-config-files">配置文件</link> 。</para>
<para>关于fontconfig配置的更多细节，可以查看官方文档： <link xlink:href="http://www.freedesktop.org/software/fontconfig/fontconfig-user.html"/>，也可以查看ArchWiki里的相关说明： <link xlink:href="https://wiki.archlinux.org/index.php/Font_Configuration"/>。</para>
</sect2>
</sect1>
</chapter>

<chapter><title>资源管理</title>

<para>计算机通过文件系统组织和管理资源，可以把文件系统理解为一个抽屉，而其中存放着许多的文件夹或文件，而在文件夹里可以再存放文件或文件夹。只不过计算机中的文件夹与现实的一点不同是它可以无限制的嵌套。</para>
<para>而对于用户来说，作为一个资源管理工具，必须要提供的基本操作包括：打开文件、移动、重命名、删除文件等。而进行这些操作的一个前提是可以快捷地定位文件。</para>
<para>在Linux中，由于命令行程序的广泛使用，资源管理工具并不是必需的，所有相关功能都可以在命令行下完成。但对于普通的桌面用户来说，增加了不必要的学习负担，所以这里介绍使用lfm<footnote><para>lfm是Last File Manager的缩写，详细信息可以查看官方网站：<link xlink:href="http://www.terra.es/personal7/inigoserna/lfm/"/>。</para></footnote>来进行资源管理。</para>
<para>lfm本身是一个字符界面的程序，但这并不影响它在桌面环境下的使用<footnote><para>在Windows中，字符界面的程序几乎不再使用，而Linux中则依然有大量的使用，不仅仅是一些开发时间较早的程序，就是一些新近设计开发的程序而有一些选择使用字符界面，这可以是出于程序的稳健以及开发维护复杂度的考虑。</para></footnote>。比如通过下面的命令可以利用sakura虚拟终端打开lfm，再将该命令利用上面介绍的<command>xchainkeys</command>工具定制快捷键，就可以用类似Windows中的Win+E的方式对系统资源进行管理。</para>
<screen>sakura --title 'File Manager' -e lfm</screen>
<para>另外，除了的对普通文件进行管理外，像多媒体文件，比如音频文件，现在很多音频播放器都提供媒体库功能，可以通过它们实现对音频文件的分类管理。</para>
<para>接下来先简单介绍lfm的使用，再来讨论与资源管理相关的其它一些话题。</para>

<sect1><title>lfm介绍</title>
<sect2><title>文件定位</title>
<para>要实现文件的快速定位，需要从以下几个方面考虑：</para>
<variablelist>
<varlistentry><term><literal>方便的目录切换</literal></term>
<listitem><para>lfm中有多种方式进行目录切换，通过<literal>g</literal>键可以直接输入想要打开的目录。也可以在列表中通过左右方向键进行上下层目录的切换。</para></listitem>
</varlistentry>
<varlistentry><term><literal>文件搜索</literal></term>
<listitem><para>对于文件的搜索，lfm中可以通过<literal>Ctrl+S</literal>在当前列表中搜索。也可以通过<literal>/</literal>命令在当前目录下进行递归搜索。</para></listitem>
</varlistentry>
<varlistentry><term><literal>排序</literal></term>
<listitem><para>lfm的<literal>s</literal>命令可以对文件进行各种方式的排序。由于系统为UTF-8编码环境，中文无法以拼音字母顺序进行排列。</para></listitem>
</varlistentry>
<varlistentry><term><literal>文件名定位</literal></term>
<listitem><para>在Windows的资源管理器中，可以通过文件名的首字母对文件进行快速定位。而在lfm中可以通过<literal>Ctrl+S</literal>搜索命令取代，与排序同样的一个问题是，对中文文件的定位并不方便，因为需要输入中文。</para></listitem>
</varlistentry>
<varlistentry><term><literal>快捷方式</literal></term>
<listitem><para>Windows的快捷方式对应于Linux的符号链接，lfm中可以通过<literal>l</literal>命令创建。</para></listitem>
</varlistentry>
</variablelist>
</sect2>
<sect2><title>打开文件</title>

<para>对于打开文件的操作，主要是需要对不同的文件类型进行判断。在lfm中，需要通过配置文件进行指定。配置文件存放在<literal>$HOME/.lfmrc</literal>，通过<code>[Programs]</code>和<code>[File types]</code>这两段配置可以指定，例如以下配置指定使用acroread打开pdf文件。</para>
<screen>[Programs]
...
pdf: acroread
...

[File Types]
...
pdf: pdf
...</screen>
<para>另外lfm可以通过F3查看文件，通过F4编辑文件。编辑和查看所使用的程序可以在<code>[Programs]</code>中的<code>editor</code>和<code>pager</code>指定。</para>
<para>更多类型的设置可以参考这里的配置：<link xlink:href="https://github.com/dram/configs/tree/master/.lfmrc"/>。</para>
</sect2>
<sect2><title>其它操作</title>

<para>在lfm中，删除使用<literal>F8</literal>，重命名使用<literal>F2</literal>，复制使用<literal>F5</literal>，移动使用<literal>F6</literal>。</para>
<para>通过<literal>INSERT</literal>可以同时选中多个文件进行批量操作。</para>
<para>lfm还有其它很多实用的功能，具体可以查看<link xlink:href="http://www.terra.es/personal7/inigoserna/lfm/#keys"/>。</para>
</sect2>
<sect2><title>lfm的不足</title>
<para>总的来说，lfm作为文件管理工具，基本功能已经比较完善，主要的不足有：</para>
<orderedlist>
<listitem><para>对中文的支持并不理想；</para></listitem>
<listitem><para>按键上没有vifm方便；</para></listitem>
<listitem><para>没有Trash(回收站)功能；</para></listitem>
<listitem><para>没有整合<command>locate</command>工具。</para></listitem>
</orderedlist>
</sect2>

</sect1>
<sect1><title>文件权限</title>

<para>Linux从最初就是作为多用户操作系统进行设计，所以它的文件权限管理非常完备。Linux中每一个文件或文件夹都可以对三类用户分别设置权限：文件拥有者、文件所属用户组以及其它用户。每类用户都可以有读、写、执行三类权限。可以通过umask命令对创建文件时的默认权限进行设置。</para>

<para>但对于普通桌面用户来说，一般为个人使用，所以不需要特别关心。</para>
</sect1>
<sect1><title>数据备份</title>

<para>在计算机中，数据对于用户来说往往是最为重要的。所以对于重要数据必须进行必要的备份。可以考虑像Dropbox这类网络硬盘方式，它对Linux也有较好的支持。如果文件不大，也可以考虑使用邮箱进行数据备份，利用cron定时将数据打包以附件形式发送给邮箱。</para>
<para>而对于一些不涉及版权问题并希望与其他人分享的数据，也可以在github, googlecode等免费代码管理服务中进行备份。下面就以本文涉及到的配罟文件为例，说明基本的使用方式。</para>
<sect2 xml:id="manage-configs"><title>配置文件管理</title>

<para>Linux程序和Windows程序在设计理念上的一个重要不同是，Linux程序大量采用可以直接编辑的文本配置文件。其中的一个好处是，可以通过版本控制程序来管理这些配置文件。</para>
<para>配置文件经由版本控制管理后，可以追溯以前的修改，同时如果将其放在网络上的公共版本管理服务中，还可以与其他用户分享。</para>
<para>版本管理工具有很多，比如Subversion, Git, Mercurial等，下面主要介绍如何通过git工具下载本文中的配置。关于git的基本使用方法介绍，可以从这里查看：<link xlink:href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html"/>。</para>
<para>通过以下命令，可以下载本文涉及的所有配置文件：</para>
<screen>git clone git://github.com/dram/configs.git</screen>
<para>但使用上面的命令下载的配置文件并没有直接存放到<literal>HOME</literal>目录中。可以通过在<literal>HOME</literal>目录执行下面的命令，将这些文件导入到HOME目录：</para>
<screen>git init
git remote add github git://github.com/dram/configs.git
git fetch github
git checkout master</screen>
</sect2>
</sect1>
</chapter>

<chapter><title>输入法</title>

<para>在PC中输入文字，一般有这样几种方式：键盘输入、手写识别和语音识别。而现在主要的输入方式还是依靠键盘完成。</para>
<para>对于英文，所有单词都是由26个字母组成，所以可以通过键盘直接输入需要的单词。而对于中文来说，由于字符太多，不可能将每一个汉字与键盘上的按键一一对应，所以只能通过将键盘上的几个字母的组合对应为一个汉字或词组，以此实现中文的输入，对于这一对应关系的处理就是输入法的主要功能之一。</para>
<para>输入法是非常重要的基础性应用程序，所以不管在Windows还是Linux下，都已经有比较完善的支持。在这里，为了让输入法与之后将要介绍的Vim编辑器较好的协同工作，选用了uim这一输入法框架，并在它原有郑码输入法的基础上对其加以完善。这里主要参考了Windows中极点郑码的设计，因为对于输入法来说，非常重要的一点是与其它系统保持一致。另外在设计中，尽量保证每次字词输入按键的一致性，以便于提高输入速度。</para>
<para>相关的代码在：<link xlink:href="https://github.com/dram/configs/blob/master/.uim.d/plugin/zhengma.scm"/>。另外uim的配置文件可以参考这里：<link xlink:href="https://github.com/dram/configs/blob/master/.uim"/>。</para>
<para>下面就来介绍uim输入法的一些细节。</para>

<sect1><title>安装</title>
<para>在Linux中，输入法是通过动态库的方式整合到应用程序中的，所以在安装时需要指定需要加载的输入法模块。在GTK中，可以通过<command>gtk-query-immodules-2.0</command>命令查找当前安装的所有输入法，在其中找到于uim相关行，将其加入到<filename>/etc/gtk-2.0/gtk.immodules</filename>文件中。再通过设置下面环境变量即可完成uim的基本安装设置。</para>
<screen>export GTK_IM_MODULE=uim
export XMODIFIERS=@im=uim
export QT_IM_MODULE=uim</screen>
<para>这里对uim郑码输入的完善是通过uim模块的方式实现的，安装的方法是将上面提及的文件存放在<literal>$HOME/.uim.d/plugin/</literal>目录，再通过下面的命令对其进行加载：</para>
<screen>uim-module-manager --register zhengma --path $HOME/.uim.d/plugin/</screen>
<para>另处还需要安装郑码的码表文件，这里对uim原先的郑码码表进行了一些调整，相关脚本在这里可以找到：<link xlink:href="https://github.com/dram/configs/tree/master/tools/uim-table/"/>。</para>
</sect1>
<sect1><title>功能完善</title>

<para>接下来简要说明这个郑码模块对原有uim中文输入的优化。</para>
<sect2><title>自动上屏</title>
<para>在郑码中，最大码长了4码，所以在极点郑码中，如果已经输入4码，并且没有重码，那么会将唯一的候选词直接上屏。uim中虽然有自动上屏功能，但它会将不到4码的字也直接上屏，并不符合一般的中文输入习惯，这里进行了相应的调整。</para>
</sect2>
<sect2><title>第二候选词</title>
<para>由于对于郑码这类形码输入法来说，重码出现的几率不高，并且在单字输入时，即使有重码，大多也只是两重的，所以需要一个便捷的方法来选取第二候选词。uim默认不具有这一功能，这里与极点保持一致，使用<literal>;</literal>作为第二候选词的按键。</para>
</sect2>
<sect2><title>英文上屏</title>
<para>在编辑一些文档时，可能需要同时输入中英文，这样就需要输入法支持的开启状态下输入少量中文。这里与FCITX一致，使用回车键对英文进行直接上屏。</para>
</sect2>
<sect2><title>状态提示</title>
<para>在中英文混合输入时，由于经常在中英文输入之间进行切换，所以输入法应该能够直接地提示当前处于什么状态。这里使用候选框作为状态的提示，中文状态下候选框始终显示，而英文状态下不显示。</para>
</sect2>
<sect2><title>单字</title>
<para>在大多中文输入法中，一般都提供是否只输入单字的选项，而这里直接在码表中进行处理，删除了码表中的所有词组。</para>
</sect2>
<sect2><title>筛选简体中文</title>
<para>与单字输入的处理相似，这里通过在码表中删除所有繁体中文的方式实现只输入简体中文的功能，这样可以减少重码数。</para>
</sect2>
</sect1>
<sect1 xml:id="vim-input-method"><title>Vim协同工作</title>

<para>对于让输入法与Vim模式切换协同工作的实现方式，主要可以分为在编辑器实现和在输入法中实现。以下对这两者分别予以说明。</para>
<sect2><title>编辑器实现</title>

<para>编辑器中的实现可以查看GVim的<literal>imdisable</literal>和<literal>noimdisable</literal>参数，具体可以如下设置：</para>
<screen>autocmd! InsertLeave *  set imdisable
autocmd! InsertEnter *  set noimdisable</screen>
<para>通过上面的配置可以让GVim在离开和进入输入模式时对自身窗口的XIM进行同步切换。具体的动作可以描述为：</para>
<orderedlist>
<listitem><para>从INSERT转为NORMAL模式时，输入法被禁用。</para></listitem>
<listitem><para>从NORMAL模式转到INSERT时，如果之前输入法是开启的，将依然保持状态。</para></listitem>
</orderedlist>
<para>但这一方式只适用于GVim，对于虚拟终端下的Vim则不能起作用，因为Vim无法控制虚拟终端的XIM。并且不同输入法在GVim中imdisable和noimdisable切换时的行为也不同，所以实际效果并不理想。</para>
</sect2>
<sect2><title>输入法实现</title>
<para>而另一种实现方式是在输入法中实现。比如在SCIM中可以通过将关闭输入法快捷键设置为<literal>ESC + KeyRelease</literal>，也就是将ESC的KeyPress的动作传递给Vim，对KeyRelease动作进行捕捉。</para>
<para>但这只实现了上述两点中的第1点。在重新回到INSERT模式时，因为SCIM无从知道Vim是否已经回到了INSERT模式，所以无法实现输入法的自动重新开启。</para>
</sect2>
<sect2><title>另一种选择</title>
<para>在这里，通过在输入法中增加临时停用及恢复的功能，再在Vim中通过外部程序模似按键的方式实现了上述两点功能。主要思路为在输入法中监测<literal>ESC</literal>和<literal>Ctrl+C</literal>按键，在有这两个按键时，临时关闭输入法。而在Vim中，在InsertEnter事件时调用外部程序模拟键盘事件，触发输入法临时停用的恢复功能。模拟键盘事件的程序可以在这里查看：<link xlink:href="https://github.com/dram/configs/tree/master/tools/fake-key/"/>。</para>
</sect2>
</sect1>
</chapter>

<chapter><title>网络</title>

<para>从最开始的静态网页、电子邮件以及Telnet BBS，到现在的博客、网上购物、社交、微博，网络的发展不可谓不快。网络的发展，不仅仅技术的革新，更是在技术应用上的发展，而这些都切切实实地改变着我们的生活。</para>
<para>网络给我们带来了更为迅速的信息传播，更为便捷的通信方式。但网络也必有其弊端，那么我们又该警惕什么呢？比如信息爆炸，比如永久在线，还有更多层出不穷地网络新概念，这些都是值得我们思考的。网络已经不仅仅是一个技术问题，它更是一个社会问题。</para>
<para>下面简单介绍Linux中的浏览器以及通信工具。</para>
<sect1><title>浏览器</title>

<para>现在占主导地位的浏览器主要有Mozilla的Firefox，Google的Chrome，Apple的Safari以及Microsoft的IE。作为网络的重要入口，各浏览器之间的竞争自然也是热闹非凡。也可以从浏览器之间的比较中看出对于一个软件来说什么是最为重要的。</para>

<para>对于浏览器来说，非常关键的几个参数是：</para>

<variablelist>
<varlistentry><term>稳定性</term>
<listitem><para>稳定性是对于绝大部分软件的基本要求，而对于浏览器来说也非常重要，因为WEB中存在大量不符合标准的网站，浏览器必须能保证不会因为这些网站而导致自身崩溃。</para></listitem>
</varlistentry>
<varlistentry><term>兼容性</term>
<listitem><para>由于WEB标准的滞后，以及不同浏览器这间的兼容性问题，一个网站在设计时很可能只考虑在某一个或几个特定的浏览器中正常使用。而浏览器的设计应该在保证遵循标准的同时，尽可能地与其它浏览器保持兼容，从而减轻网页开发者和使用者的负担。</para></listitem>
</varlistentry>
<varlistentry><term>安全性</term>
<listitem><para>WEB应用的安全主要需要从两方面考虑，一是同站自身的安全，再是浏览器的安全。</para></listitem>
</varlistentry>
<varlistentry><term>性能</term>
<listitem><para>由于现在的网络应用越来越复杂，对于网络性能上的要求也就越来越高。网络整体的性能受多方面的影响，比较网络带宽，网络接口，协议设计以及实现等。而浏览器也是非常重要的一环，比如渲染引擎的性能，包括对HTML, CSS, Javascript等的解析，再比如缓存机制、预加载等。</para></listitem>
</varlistentry>
<varlistentry><term>功能</term>
<listitem><para>而在功能性上，由于不同用户对于WEB应用有着全然不同的需求，要同时满足这些用户，需要有一个方便的扩展接口。</para></listitem>
</varlistentry>
</variablelist>

<para>这里选择使用Firefox，主要是因为它较为丰富的插件，以及它较大的市场占有率。下面对Firefox做一些简单的介绍。</para>

<sect2><title>插件</title>
<para>下面例举一些在Firefox中常用的插件：</para>
<variablelist>
  <varlistentry><term>Adblock Plus</term>
    <listitem><para>屏蔽广告。可以定阅不断更新的URL列表，能够屏蔽大部分中英文广告。</para></listitem>
  </varlistentry>
  <varlistentry><term>DownThemAll!</term>
    <listitem><para>多线程下载工具。</para></listitem>
  </varlistentry>
  <varlistentry><term>Flashblock</term>
    <listitem><para>屏蔽页面中所有的Flash。Flash对浏览器整体的性能有较大影响，使用Flashblock插件可以让页面中的所有Flash默认不显示，如有需要显示的可以手动开启。</para></listitem>
  </varlistentry>
  <varlistentry><term>Gmail Watcher</term>
    <listitem><para>Gmail邮件提醒。于Gmail邮件提醒相关的Firefox插件有很多，但总体来说Gmail Watcher最为完善。</para></listitem>
  </varlistentry>
</variablelist>
</sect2>
<sect2><title>其它</title>
<para>下面再来介绍一些Firefox的快捷键。如果需要完全使用键盘控制Firefox，可以考虑使用vimperator插件，具体可以看这里：http://vimperator.org/。</para>
<variablelist>
  <varlistentry><term>Ctrl+L</term>
    <listitem><para>转到地址栏</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+K</term>
    <listitem><para>搜索栏</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+Tab</term>
    <listitem><para>标签页切换</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+T</term>
    <listitem><para>新建标签页</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+W</term>
    <listitem><para>关闭标签页</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+R，F5</term>
    <listitem><para>刷新页面，另外Ctrl+F5可以让浏览器忽略自身缓存</para></listitem>
  </varlistentry>
  <varlistentry><term>Alt+Left Alt+Right</term>
    <listitem><para>后退、前进</para></listitem>
  </varlistentry>
  <varlistentry><term>Ctrl+左键</term>
    <listitem><para>在新标签页打开键接</para></listitem>
  </varlistentry>
</variablelist>
</sect2>
</sect1>
<sect1><title>通信工具</title>

<para>PC的通信工具基本上有Email、IRC、即时通信工具等。Linux中有相应工具对其支持。比如Pidgin、Thunderbird等。由于使用方法比较直观，这里不再做介绍。</para>
<para>这些技术虽然给我们带来了便捷，但同时带来了一些问题，比如安全问题、隐私问题、真实性问题等等。</para>
</sect1>
</chapter>

<chapter><title>文本编辑</title>

<para>对于一个桌面应用系统来说，文本编辑器其实并不是必需的。就比如在Windows中，对一般用户来说，如果有Word等文字处理工具，那么记事本被使用到的频率并不高。但在Linux中有所不同，在很多时候都需要用到文本编辑器。一方面是因为Linux中大量使用文本配置文件，而另一方面Windows中Word的文字处理功能，在Linux中可以通过文本编辑器实现，这将在下一章再作介绍。</para>
<para>如果只是需要文本编辑器的基本的、核心的功能，那么像记事本这样的程序就可以满足要求，但如果需要更为便捷、更为复杂的功能，那就要使用更为强大的编辑器了。Linux中的编辑器多得甚至于无法记数，最为流行的有Vim和Emacs，下面将要介绍的就是其中的Vim。</para>
<para>Vim的基本操作就不在这里作介绍了，不太熟悉的读者可以通过<literal>vimtutor</literal>命令学习，下面介绍的主要是一些零散的技巧。</para>
<para>相关的详细配置可以在<link xlink:href="https://github.com/dram/configs/tree/master/.vimrc"/>和<link xlink:href="https://github.com/dram/configs/tree/master/.vim/"/>中查看。</para>
<sect1><title>中文处理</title>

<para>有必要先就Vim的中文支持作一说明。Vim本身对于多语言已经有较好的支持。只是在中文句点判断、输入法切换上还不太方便，下面介绍对这些问题的处理。</para>
<sect2><title>文件编码</title>

<para>在Vim中针对文件编码的选项主要有三个：<literal>fileencoding</literal>、<literal>fileencodings</literal>和<literal>encoding</literal>。其中<literal>encoding</literal>指Vim自身在存储信息时的编码，而<literal>fileencoding</literal>对文件写入起作用，用于指定Vim使用什么编码写入文件。<literal>fileencodings</literal>作用于读取文件时，Vim尝试使用<literal>fileencodings</literal>里所列编码读取文件，如果尝试成功，则将<literal>fileencoding</literal>设置为该编码。</para>
<para>读取文件时，除了参考<literal>fileencodings</literal>之外，也可以用<literal>:edit ++enc=gbk</literal>的形式直接指定编码。</para>
<para>基于上面的说明，如果需要更改文件编码，首先通过设置<literal>fileencodings</literal>或直接指定<literal>++enc</literal>参数使Vim正常显示文本，再设置<literal>fileencoding</literal>并保存即可。</para>
</sect2>
<sect2><title>中文句点</title>

<para>Vim是基于英文的词语和句子来定义移动的，这样在中文的行内移动就会比较麻烦。对于词语，没有什么好的处理办法，因为这涉及到中文分词问题。而中文句子间的移动还是可以通过配置来实现的。</para>
<para>英文句子间移动的命令是<literal>(</literal>和<literal>)</literal>，下面配置对这两个命令进行重新定义，使其支持对中文句点的判断。</para>
<screen>nmap &lt;silent&gt; ( :call search('\n\\|。\\|！\\|？\\|\.\s\\|!\s\\|?\s', "bw")&lt;CR&gt;
nmap &lt;silent&gt; ) :call search('\n\\|。\\|！\\|？\\|\.\s\\|!\s\\|?\s', "w")&lt;CR&gt;</screen>
</sect2>
<sect2><title>输入法切换</title>

<para>在GVim中可以通过下面的设置实现在切换INSERT和NORMAL模式时关闭或重新开启输入法。</para>
<screen>autocmd! InsertLeave *  set imdisable
autocmd! InsertEnter *  set noimdisable</screen>
<para>但上面的命令只对GVim有效，终端下的Vim是无效的，因为实际上<literal>imdisable</literal>作用的是当前的图形窗口程序的输入法开关，而并非是输入法程序的开关。</para>
<para>至于终端下的Vim，也可以使用在<link linkend="vim-input-method">输入法</link> 一章所介绍的方法。</para>
</sect2>
</sect1>
<sect1><title>普通编辑</title>

<para>接下来介绍在使用Vim编辑普通文件时的一些小的技巧。</para>

<sect2><title>移动</title>

<para><literal>*</literal>和<literal>#</literal>是两个非常有用的快捷键，可以正向或反向查找光标所在单词。</para>
<para>Vim虽然在显示较长文本行时，会对其进行折叠，然而普通的<literal>j</literal>和<literal>k</literal>命令依然只是在真实的行之间进行移动，但可以使用<literal>gj</literal>和<literal>gk</literal>命令在行内的折叠行间移动。</para>
<para>行内的移动还可以通过<literal>f</literal>和<literal>F</literal>命令处理，这两个命令用于进行行内搜索。<literal>;</literal>用于重复<literal>f</literal>或<literal>F</literal>的动作。</para>
<para>更为复杂的移动操作可以通过mark实现，<literal>m[a-z]</literal>用于标记光标当前位置，通过<literal>`[a-z]</literal>回到相应mark所在位置，而<literal>'[a-z]</literal>则是回到mark所在行。</para>
</sect2>
<sect2><title>换行符</title>

<para>在Winodows中以<literal>\r\n</literal>表示换行，Unix中以<literal>\n</literal>表示，Mac中以<literal>\r</literal>表示，因为这个原因，在跨平台工作时，还是会带来不少麻烦的，好在Vim中可以方便地对换行符进行识别和转化。</para>
<para>Vim中换行符的处理与上面说明的文件编码处理是类似的，<literal>fileformats</literal>作用于读取，<literal>fileformat</literal>作用于写入。而<literal>++ff</literal>对应于<literal>++enc</literal>。</para>
</sect2>
<sect2><title>复制粘贴</title>

<para>在桌面环境一章中已经提到，X11窗口系统中有两套复制粘贴的方式，但可以通过<literal>autocutsel</literal>命令将其同步。而在Vim中，又有其自身的复制粘贴的方式。具体说来，Vim中的<literal>"*</literal>register相对于 X11 的selection，而<literal>"+</literal>相对于X11的clipboard。</para>
</sect2>
<sect2><title>文件切换</title>

<para>在编辑文件时，往往不是对单个文件进行处理，而是同时对多个文件进行编辑。这样在文件之间方便地切换就显得比较重要了，下面介绍常用的几种方式。</para>
<sect3><title>打开文件所在目录</title>

<para>编辑的多个文件常常在同一目录中，这时可以通过<literal>:cd %:h</literal>命令让Vim先跳转到该目录，再结合<literal>:edit</literal>命令以及<literal>Ctrl-D</literal>补全打开需要的文件。</para>
<para>也可以直接使用<literal>:edit %:h</literal>命令，通过Vim的netrw组件打开该目录。</para>
<para>另外还可以在Vim配置文件中加入下面的配置，这样在输入<literal>:edit %/</literal>之后，Vim会将<literal>%/</literal>替换为当前文件所在目录的路径。</para>
<screen>cmap %/ &lt;C-R&gt;=expand("%:p:h")."/"&lt;cr&gt;</screen>
</sect3>

<sect3><title>MRU插件</title>

<para>MRU<footnote><para>MRU插件可以从<link xlink:href="http://www.vim.org/scripts/script.php?script_id=521"/>下载，存放到<filename>$HOME/.vim/plugin/</filename>目录下即可。</para></footnote>插件用于记录最近打开的文件。通过<literal>:MRU</literal>命令打开MRU窗口。由于经常使用，可以对其设置快捷键：</para>
<screen>let mapleader = ','
nmap &lt;silent&gt; &lt;leader&gt;m         :MRU&lt;CR&gt;</screen>
</sect3>
<sect3><title>buffer</title>

<para>Vim对于打开过的文件，会以buffer的形式加以管理。通过<literal>:buffers</literal>或<literal>:ls</literal>命令可以查看当前打开的所有文件。<literal>:bn</literal>和<literal>:bp</literal>命令用于在buffer间切换，也可以使用<literal>:b num</literal>直接跳转到指定buffer。<literal>:bd</literal>用于删除buffer。另外如果不想关闭Vim，只是想关闭对该文件的编辑，可以使用<literal>:bd</literal>代替<literal>:q</literal>。</para>
</sect3>
<sect3><title>最近编辑</title>

<para>在编写程序时，经常需要在两个文件之间进行切换，比如<literal>.h</literal>和<literal>.c</literal>文件间，或者实现与调用间，或者实现与测试间，或者编辑和帮助间的切换，<literal>CTRL-6</literal>,<literal>CTRL-^</literal>或<literal>:e #</literal>可以用来在两个最近编辑的文件间切换。</para>
<para>具体说明可以查看<literal>:h CTRL-6</literal>。</para>
</sect3>
</sect2>
<sect2><title>INSERT模式</title>

<para>Vim注重NORMAL模式下的便捷处理，在INSERT模式下一般主要还是进行简单的文本输入操作。但Vim也支持在INSERT模式下的一些快捷操作。</para>
<para>比如<literal>CTRL-W</literal>可以删除一个单词，而<literal>CTRL-U</literal>可以删除一整行。另外<literal>CTRL-N</literal>和<literal>CTRL-P</literal>这两个快捷键可以进行简单的文本补全。</para>
<para>通过<literal>:h ins-special-keys</literal>可以查看INSERT模式下所有快捷方式的详细说明。</para>
</sect2>
</sect1>
<sect1><title>代码编写</title>

<para>Vim更多的是用于代码编写，它对于大多数语言都有很好的支持。以下介绍一些使用Vim进行代码编写的技巧。</para>
<sect2><title>代码风格</title>

<para>不同类型的程序往往会有不同的代码风格，比如C语言一般以Tab缩进，而Python则更多的以4个空格进行缩进。</para>
<para>在Vim中可以在<filename>$HOME/.vim/ftplugin/</filename>目录中创建以类型名启始命名的文件对该类型进行定制。比如可以在<literal>$HOME/.vim/ftplugin/python_own.vim</literal>文件中加入：</para>
<screen>setl shiftwidth=4
setl expandtab</screen>
<para>甚至可以为不同的文件类型创建不同的快捷键，同样是在该文件中加入下面的配置后，可以通过<literal>&lt;leader&gt;r</literal>快捷键运行该Python脚本文件。</para>
<screen>nmap &lt;buffer&gt; &lt;leader&gt;r         :w&lt;cr&gt;:!python %&lt;cr&gt;</screen>
<para>另外，通过colorcolumn可以在代码行超出指定长度时给予提示，从而保持良好的代码风格，具体配置如下：</para>
<screen>set colorcolumn=81
hi ColorColumn ctermbg=darkgrey</screen>
</sect2>
<sect2><title>text objects</title>

<para>Vim有一text object的概念，这在编写程序时非常有用，可以对<literal>()</literal>,<literal>""</literal>,<literal>&lt;&gt;&lt;/&gt;</literal>等整体进行处理，比如<command>di(</command>可以删除括号内的文本，<command>ci"</command>可以修改引号内的文件。详细说明可以查看<literal>:h text-objects</literal>。</para>
</sect2>
<sect2><title>简单的模板</title>

<para>很多的程序文件特别是脚本语言中每个文件都有部分固定的格式，在Vim中可以通过<literal>autocmd</literal>命令实现简单的模板功能，以避免重复劳动。下面以Python脚本为例作简单说明。</para>
<para>首先需要一个模板文件，比如<literal>~/.vim/templates/template.py</literal>：</para>
<screen>#!/bin/env python
# vim: set fileencoding=utf-8


if __name__ == '__main__':
    pass</screen>
<para>再是在<literal>.vimrc</literal>中通过<literal>autocmd</literal>命令设置在新建<literal>.py</literal>文件时自动读取模板中的内容：</para>
<screen>au BufNewFile *.py :0r ~/.vim/templates/template.py</screen>
</sect2>
</sect1>
<sect1><title>其它技巧</title>

<sect2><title>查看man</title>

<para>Vim下的<literal>:Man</literal>可以用来查看man文档。这在编写C程序或SHELL脚本时都非常有用。</para>
</sect2>
<sect2><title>Caps Lock替换ESC</title>

<para>很多Emacs的用户会将Caps Lock键替换为Ctrl，而在Vim也可以借鉴这一方式，将Caps Lock替换为Esc键。</para>
<para>首先创建<literal>$HOME/.Xmodmap</literal>文件，内容为：</para>
<screen>! Swap caps lock and escape
remove Lock = Caps_Lock
keysym Escape = Caps_Lock
keysym Caps_Lock = Escape
add Lock = Caps_Lock</screen>
<para>然后在<literal>$HOME/.xinitrc</literal>中加入：</para>
<screen>if [ -f ~/.Xmodmap ]; then
    xmodmap ~/.Xmodmap
fi</screen>
<para>另外，在Windows中也可以通过注册表设置，用以下内容创建reg文件并运行即可。</para>
<screen>REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00</screen>
</sect2>
</sect1>
<sect1><title>扩展</title>

<para>Vim的一个重要特点是可以通过多种语言对其进行扩展，同时它也有自身的脚本语言。在下面的多媒体一章将使用Vim的可扩展性实现一个简单的音频播放器。</para>
</sect1>
</chapter>

<chapter><title>文字处理</title>

<para>在Windows中，较为常用的文字处理软件是WPS或者Word等所见即所得(WYSIWYG<footnote><para>WYSIWYG是What You See Is What You Get的缩写。关于它的详细说明，可以看这里：<link xlink:href="http://en.wikipedia.org/wiki/WYSIWYG"/>。</para></footnote>)的编辑器。Linux也有类似的工具，比如OpenOffice.org、KOffice等。</para>
<para>但除了所见即所得编辑器之外，还可以使用TeX等标记型语言来处理文档的排版，相对于所见即所得的编辑器来说，使用标记型语言编写的文档维护更加方便、样式更为统一，很多时候最终生成的文档也更为美观。</para>
<para>但这类标记型语言有一个的缺点是标记比较复杂，有一定的入门门槛，并且在编写文档时经常需用输入大量的标记。不过通过对编辑器进行合理的配置可以部分解决这一问题。下面主要介绍编写本文所使用的DocBook标记语言，它以XML格式来组织文本。</para>
<para>读者也可以选择一些轻量级标记语言，比asciidoc, txt2tags, markdown, pandoc等，相对来说，这些轻量级的标记语言标记更为简洁。它们不是直接生成最终文档，而是先转化为Tex、Docbook等标记语言，再最终转化为所需要的文档。</para>
<para>这里使用的是DocBook 5.0版，详细的文档可以查看<link xlink:href="http://www.docbook.org/tdg5/en/html/docbook.html"/>和<link xlink:href="http://www.sagehill.net/docbookxsl/index.html"/>。</para>

<sect1><title>工具</title>
<para>由于DocBook本身是XML文档，所以可以借助一些通用的XML处理工具对DocBook文档进行处理。这里主要用到了Jing<footnote><para>另一个常用的XML格式检查工具是xmllint，相对来说，Jing对RELAX NG有更好的支持，这在编写DocBook文档时非常重要，借助于它可以更容易发现可能的格式错误。</para></footnote>和xsltproc这两个工具，分别用于语法检查和格式转化。</para>
<para>先从DocBook官网下载DocBook5.0 Schemas的代码(http://www.docbook.org/xml/5.0/docbook-5.0.zip)，可以通过其中的<filename>rng/docbook.rng</filename>文件结合Jing工具对DocBook文档进行语法上的检查，具体方式如下：</para>
<screen>java -jar /path/to/jing.jar /path/to/rng/docbook.rng file.xml</screen>
<para>而DocBook到其它格式的转化则需要借助与docbook-xsl-ns(http://sourceforge.net/projects/docbook/files/)和xsltproc工具，下面的命令就是通过它们将DocBook文档转化为fo文档，之后再交由FOP工具将fo转化为pdf文档：</para>
<screen>xsltproc -o output.fo /path/to/xsl-ns-stylesheets/fo/docbook.xsl input.xml</screen>
<para>关于FOP的设置随后会详细介绍，接下来先介绍对编辑器的配置。</para>
</sect1>

<sect1><title>编辑器</title>

<para>这里选择使用Vim作为DocBook文档的编辑器，Vim自身对XML编辑上的支持并不多，需要先从<link xlink:href="http://www.vim.org/scripts/script.php?script_id=1397"/>下载一个插件，这个插件可以对XML tag进行自动补全，并提供tag跳转等功能。</para>
<sect2><title>语法</title>
<para>由于DocBook文档一般是较大，并且有较多的长行，Vim在对这类XML文本进行语法高亮时性能较差，直接影响编辑的效率，所以有必要对它进行一些调整。<link xlink:href="https://github.com/dram/configs/blob/master/.vim/syntax/docbk.vim"/>这份Vim语法文件是针对DocBook进行的精减，同时支持对章节的代码折叠，在DocBook文档的最后加入下面modeline的设置即可加载该文件并启用折叠：</para>
<screen>&lt;!-- vim: set ft=docbk fdm=syntax : --&gt;</screen>
</sect2>
<sect2><title>缩进</title>
<para>Vim默认开启XML文档的缩进，如果需要关闭的话，可以在<filename>$HOME/.vim/indent/</filename>目录新建<filename>xml.vim</filename>文件，加入下面的内容：</para>
<screen>let b:did_indent = 1</screen>
</sect2>
<sect2><title>折叠</title>
<para>在语法一节中已经提到如何开启代码折叠，另外还可以在ftplugin中设置<literal>foldlevel</literal>以及<literal>foldnestmax</literal>这两个参数设置默认展开几级以及最多折叠几级。</para>
</sect2>
<sect2><title>移动</title>
<para>在安装了xml.vim插件之后，可以通过<literal>[[</literal>, <literal>]]</literal>, <literal>[]</literal>, <literal>][</literal>这几个按键在XML标签之间移动。但感觉默认的设置不是很习惯，可以在xml.vim中对其进行重新配置，可以参考<link xlink:href="https://github.com/dram/configs/tree/master/.vim/ftplugin/xml.vim"/>，重新设罟后的按键含义为：</para>
<variablelist>
<varlistentry><term><literal>[[</literal></term><listitem><para>上一个open tag</para></listitem></varlistentry>
<varlistentry><term><literal>[]</literal></term><listitem><para>上一个close tag</para></listitem></varlistentry>
<varlistentry><term><literal>][</literal></term><listitem><para>下一个open tag</para></listitem></varlistentry>
<varlistentry><term><literal>]]</literal></term><listitem><para>下一个close tag</para></listitem></varlistentry>
</variablelist>
</sect2>
</sect1>

<sect1><title>脚本</title>

<para>从以上的介绍中可以看到，将DocBook转化为PDF文档需要结合使用几个工具，可以通过Makefile对其进行管理，生成本文档所用的Makefile可以到这里查看： https://github.com/dram/docs/blob/master/Makefile。</para>
</sect1>

<sect1><title>FOP中文支持</title>

<para>FOP本身是支持多语言的，这里唯一需要处理的是字体设置的问题。</para>
<para>本文档使用的字体主要有：文鼎PL简报宋、文鼎PL简中楷、Computer Modern Unicode以及Droid Sans Fallback。</para>
<variablelist>
<varlistentry><term><literal>文鼎PL简报宋</literal></term>
<listitem><para><link xlink:href="http://ftp.debian.org/debian/pool/main/t/ttf-arphic-gbsn00lp/ttf-arphic-gbsn00lp_2.11.orig.tar.gz"/></para>
</listitem>
</varlistentry>
<varlistentry><term><literal>文鼎PL简中楷</literal></term>
<listitem><para><link xlink:href="http://ftp.debian.org/debian/pool/main/t/ttf-arphic-gkai00mp/ttf-arphic-gkai00mp_2.11.orig.tar.gz"/></para>
</listitem>
</varlistentry>
<varlistentry><term><literal>Computer Modern Unicode</literal></term>
<listitem><para><link xlink:href="http://canopus.iacp.dvo.ru/~panov/cm-unicode/"/></para>
</listitem>
</varlistentry>
<varlistentry><term><literal>Droid Sans Fallback</literal></term>
<listitem><para><link xlink:href="http://android.git.kernel.org/?p=platform/frameworks/base.git;a=tree;f=data/fonts"/></para>
</listitem>
</varlistentry>
</variablelist>
<para>FOP不能直接读取其中的Droid Sans Fallback字体，需要使用fontforge打开该字体再重新导出为TTF字体。</para>
<para>设置FOP的字体分两步进行。先是让FOP识别这些字体，这个通过FOP的配置文件完成，再是让PDF文档使用这些字体，这个通过DocBook的XSL文件进行设置。详细的配置可以查看下面两份文件：</para>
<variablelist>
<varlistentry><term><literal>fop.xconf</literal></term>
<listitem><para><link xlink:href="https://github.com/dram/docs/blob/master/fop.xconf"/></para>
</listitem>
</varlistentry>
<varlistentry><term><literal>fo.xsl</literal></term>
<listitem><para><link xlink:href="https://github.com/dram/docs/blob/master/fo.xsl"/></para>
</listitem>
</varlistentry>
</variablelist>
<para>最终在调用fop生成PDF文件，命令示例如下：</para>
<screen>fop -c fop.xconf input.fo output.pdf</screen>
</sect1>

<sect1><title>PDF优化</title>

<para>单是设置了字体后FOP生成的PDF效果依然不是很理想。还需要进行一些微调，配置还是写在上面提及的<literal>fo.xsl</literal>文件中。另外中英文混排的问题通过脚本进行优化。</para>

<sect2><title>中英文混排</title>

<para>在TeX中，有专门的xeCJK包提供对中英文混排的优化，而在FOP中并没有对其做优化。这样看起来中文和英文会有些拥挤，这里通过一个脚本分析DocBook的XML文件，自动在中文和英文间加入空格，以此实现与xeCJK相似的功能。</para>
<para>详细代码可以从这里查看：<link xlink:href="https://github.com/dram/docs/blob/master/optimize-char-spacing.py"/>。</para>
</sect2>

<sect2><title>排版</title>

<para>在FOP中可以对很多排版细节进行详细的设置，比如首行缩进两格可以通过下面的方式配置：</para>
<screen>&lt;xsl:attribute-set name="normal.para.spacing"&gt;
  &lt;xsl:attribute name="text-indent"&gt;2em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</screen>
<para>行距设置：</para>
<screen>&lt;xsl:param name="line-height"&gt;1.6&lt;/xsl:param&gt;</screen>
<para>还有比如正文字体大小、标题高度等等，都可以设置，这里就不再一一列举，读者可以从<literal>fo.xsl</literal>文件中找到相应的设置。关于这些参数的说明可以到这里查看：<link xlink:href="http://docbook.sourceforge.net/release/xsl/current/doc/fo/index.html"/>。</para>
</sect2>

<sect2><title>封面调整</title>
<para>在FOP中，如果需要对封面进行调整，需要先根据docbook-xsl目录中的<filename>fo/titlepage.templates.xml</filename>进行调整，再利用<command>xsltproc</command>通过<filename>template/titlepage.xsl</filename>将新的模板转化为XSL文件，之后就可以通过这个XSL文件对DocBook文本进行转化了。</para>
</sect2>
</sect1>
</chapter>

<chapter><title>多媒体</title>

<para>多媒体应用主要包括音频和视频，这里主要介绍Linux下音频播放相关内容。</para>

<sect1><title>音频播放器</title>

<para>虽然在线视听已经有多年的发展，网络收音机、音乐盒等概念也在近两年逐渐流行，但音乐播放器作为传统的桌面应用程序，依然在桌面应用中占有着非常重要的地位。所以在Linux中有着大量的音乐播放器可供选择。</para>
<para>从用户角度来说，音乐播放器中最为重要的功能包括：解码播放、资源管理、播放列表、播放控制。</para>
<para>由于没有找到合适的软件，这里通过mpg123和Vim实现了一个简易的播放器。mpg123有一个非常方便的开发接口<footnote><para>通过mpg123的<code>--remote</code>参数可以利用mpg123进程在标准输入输出对mpg123进行控制。</para></footnote>，通过它可以方便地对其进行包装。完整的代码如下：</para>
<variablelist>
<varlistentry>
<term>vim-mpg123.py</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/tree/master/bin/vim-mpg123.py"/></para></listitem>
</varlistentry>
<varlistentry>
<term>mpg123.vim</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.vim/plugin/mpg123.vim"/></para></listitem>
</varlistentry>
<varlistentry>
<term>xchainkeys配置文件</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/.config/xchainkeys/xchainkeys.conf"/></para></listitem>
</varlistentry>
</variablelist>
<para>下面分别就上述四个方面对这一播放器的实现作简要说明。</para>
</sect1>
<sect1><title>解码播放</title>
<para>这里的解码播放功能通过mpg123实现，它只支持MP3格式文件，现在虽然有OGG, WMA等有损压缩格式以及FLAC, APE等无损压缩格式的出现，但MP3依然是最为通用和流行的一种格式。如果需要对多种格式进行支持，可以考虑GStreamer等解码库<footnote><para>GStreamer提供多种语言接口，<link xlink:href="https://github.com/dram/configs/blob/master/bin/vim-gst-srv.py"/>这里是一个Python接口的示例。</para></footnote>。</para>
<para>另外，为了能通过多种途径控制播放，这里使用C/S模式组织程序，以FIFO文件为接口。</para>
</sect1>
<sect1><title>资源管理</title>
<para>现在很多播放器以媒体库的形式组织音乐，但就个人而言，简单的目录结构组织已经足够，所以这里的资源管理和浏览实际上就是在Vim编辑器中显示目录内容。同时定义了一些快捷键用于向播放器服务端发送指令。</para>
</sect1>
<sect1><title>播放列表</title>

<para>很多播放器在显示播放列表时会读取音频文件的ID3信息，而这里做了简化处理，直接显示文件名。文件名事先经过整理，包含了track number以及title信息。</para>
</sect1>
<sect1><title>播放控制</title>

<para>由于采用了C/S模式，可以实现多种播放控制方式，这里除了可以在Vim中控制外，还可以通过键盘直接控制播放，详细信息请查看xchainkeys的配置文件。</para>
<para>另外，音量控制一般会在systray下实现，像Gnome，KDE都会在systray中显示音量控制图标，显示当前音量，同时通过它也可以对音量进行调节。而其它窗口管理器也可以使用gvolwheel, pyvolwheel等程序得到同样的功能。</para>
<para>而这里则是使用ossmix、xchainkeys和libnotify<footnote><para>libnotify基于dbus通过C/S模式实现，现在的daemon端依赖于一些Gnome库，但也可以选用XFCE的daemon实现。</para></footnote>提供了完全的键盘控制，因为对于音量调节不外乎这么几个功能：增大音量、减小音量，还有静音切换。这些功能完全可以通过键盘控制。具体实现可以查看下面的代码以及xchainkeys的配置。</para>
<variablelist>
<varlistentry><term>volume-control</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/bin/volume-control"/></para></listitem>
</varlistentry>
<varlistentry><term>volume-control-alsa</term>
<listitem><para><link xlink:href="https://github.com/dram/configs/blob/master/bin/volume-control-alsa"/></para></listitem>
</varlistentry>
</variablelist>
</sect1>
</chapter>

<chapter><title>SHELL</title>

<para>本章主要来讲讲SHELL，对桌面用户来说，理想情况下并不需要了解SHELL，但了解SHELL有助于了解Linux的运作机制。同时有些与操作系统直接相关的操作也需要通过SHELL来执行。</para>
<para>接下来对SHELL作一些零散的介绍。</para>
<sect1><title>SHELL实现</title>

<para>Linux中有很多的SHELL实现，其中主要包括sh及csh两个分支。在Linux中比较普及的是bash。这里选择使用mksh，相对于bash来说，它更为轻量级，也更接近于POSIX标准。如果喜欢功能强大的SHELL，也可以考虑zsh。</para>
<para>通过<literal>chsh</literal>命令可以更换shell。</para>
<para>关于它的配置，可以参考这里：<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/dram/dram-configs/blob/master/.mkshrc">https://github.com/dram/dram-configs/blob/master/.mkshrc</link>。</para>
<para>这里在设置<literal>PATH</literal>时，将<literal>$HOME/bin/</literal>目录置于系统的命令路径之前，这样可以方便地对系统原有程序进行覆盖。通过<literal>which</literal>命令可以确认当前调用的是哪一个命令。</para>
</sect1>
<sect1><title>常用命令</title>

<para>对于桌面应用来说，有几个常用命令需要掌握：top, ps, kill。在GNOME或者KDE环境下也有对应的图形化工具。</para>
</sect1>
</chapter>

<chapter><title>其它</title>
<para>这一章主要介绍Linux桌面应用中的一些零碎技巧。</para>

<sect1><title>待办事项</title>
<para>用于日程管理的软件有很多，这里参考todo.txt(http://todotxt.com/)在Vim中实现了一个简易的基于文本的待办事项整理工具。</para>
<para>基本的想法是基于代码高亮进行筛选，基于代码折叠管理已经完成的任务。代码高亮可以在<filename>$HOME/.vimrc</filename>文件中加入下面的配置定义一个<command>:Hi</command>命令：</para>
<screen>command -nargs=1 Hi :syn clear Search | syn match Search ".*&lt;args&gt;.*"</screen>
<para>代码折叠可以直接通过在文本中结合使用modeline和标记完成。具体可以参考这个模板：<link xlink:href="https://github.com/dram/docs/blob/master/data/todo.txt"/>。</para>
</sect1>
<sect1><title>gtk icon theme</title>
<para>GTK的Icon样式存放在<filename>/usr/share/icons/</filename>或<filename>$HOME/.icons/</filename>目录下。如果是SVG格式的，注意需要安装librsvg库，并执行下面的语句：</para>
<screen>gdk-pixbuf-query-loaders > /usr/etc/gtk-2.0/gdk-pixbuf.loaders</screen>
<para>可以通过<command>gtk-update-icon-cache</command>做一定优化。</para>
</sect1>
<!--
<sect1><title>磁盘检查</title>
<para>系统默认会定期对磁盘进行检查，可以通过<command>tune2fs -c NUM /dev/hdaN</command>命令进行调整。</para>
</sect1>
<sect1><title>鼠标行为设置</title>

<para>鼠标灵敏度可以通过<command>xset m 5/8 1</command>的形式进行配置。</para>

<para>鼠标功能键可以通过<command>xmodmap -e "pointer = 1 7 3 4 5 6 2"</command>设置。</para>

</sect1>
<sect1><title>DPI</title>

<para>TODO: 有关DPI的说明</para>

<para>通过<command>xdpyinfo | gre resolution</command>可以查看系统当前的DPI。通过<command>xrandr \-\-dpi 98</command>可以对其进行设置。</para>

</sect1>
-->
<sect1><title>内核定制</title>

<para>在定制内核时首先需要考虑引导问题，其中包括磁盘IO相关驱动，文件系统相关驱动。这些驱动必须编译到内核中，而不是以模块的方式。不过现在有一个initrd文件系统，利用mkinitrd命令可以将需要的模块整合作为二次引导。</para>

<para>比如在VirtualBox中，Device Drivers->SCSI device support->SCSI (disk|CDROM|generic) 都应该编入内核。而File systems一块则可以根据需要选择。</para>

<sect2><title>声卡驱动</title>
<para>在Linux中，声卡驱动主要有OSS和ALSA两种选择。而更为上层的应用框架则又有Jack, PluseAudio等。这里使用OSS作为声卡的驱动。</para>
</sect2>
</sect1>
</chapter>

<appendix><title>Fedora软件包管理</title>

<para>包管理对于一个发行版来说是非常重要的，Fedora以RPM包的形式组织软件，主要通过rpm和yum这两个工具。其中rpm是包管理的基础程序，yum是对rpm的包装，增加了包下载及依赖的自动处理等功能。</para>
<para>关于Fedora软件管理的详细介绍，可以查看<link xlink:href="http://docs.fedoraproject.org">Feodra Software Management Guide</link>。</para>
<para>Fedora从RedHat发展而来，软件支持还是比较丰富的，除了官方的源之外，还可以到<link xlink:href="http://rpmfusion.org/">rpmfusion</link>安装官方没有收录的包。</para>
<para>在<link xlink:href="http://pkgs.fedoraproject.org/gitweb/">这里</link> 可以查看Fedora包的spec文件，不过一般不需要了解RPM包的描述方式。</para>
<para>Fedora已带有图形化的工具，但下面还是介绍rpm和yum这两个命令行工具的使用，以此对Fedora的包管理机制有一个较深入的理解。</para>
<sect1><title>YUM命令</title>

<variablelist>
<varlistentry><term><literal>yum search pattern</literal></term>
<listitem><para>查找软件包</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum install pkg-name</literal></term>
<listitem><para>从YUM源安装包</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum downgrade pkg-name</literal></term>
<listitem><para>对包进行降级，如果更新后有问题时有用</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum info pkg-name</literal></term>
<listitem><para>查看包信息</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum update [pkg-name]</literal></term>
<listitem><para>更新软件包，如果不指定名称，更新系统所有包</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum clean</literal></term>
<listitem><para>清空缓存</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum list installed ['pattern']</literal></term>
<listitem><para>显示所有安装的包，类似于<literal>rpm -qa</literal></para></listitem>
</varlistentry>
<varlistentry><term><literal>yum provides file</literal></term>
<listitem><para>显示文件所属的包，类似于<literal>rpm -qf</literal></para></listitem>
</varlistentry>
<varlistentry><term><literal>yum list extras</literal></term>
<listitem><para>显示没有库中不包含的软件包</para></listitem>
</varlistentry>
<varlistentry><term><literal>yum deplist pkg-name</literal></term>
<listitem><para>显示依赖关系</para></listitem>
</varlistentry>
</variablelist>
<para>ArchLinux中，在利用pacman删除包时，可以通过<literal>-Rs</literal>参数同时删除自动安装的依赖包。而yum没有这个功能，可以在<literal>yum-utils</literal>包中找到<literal>package-cleanup</literal>命令，通过它的<literal>--leaves</literal>参数可以查找到那些已经不再需要的lib包。</para>
<para>在利用yum update系统时，可以通过<literal>-x</literal>参数指定不升级特定包。也可以添加到<literal>yum.conf</literal>的<literal>exclude</literal>中。</para>
<para>另外，yum中还有group的概念，可以方便安装由官方分类好的一组包。包括以下几个命令：</para>
<screen>yum groupinstall
yum groupupdate
yum grouplist
yum groupremove
yum groupinfo</screen>
</sect1>
<sect1><title>YUM配置</title>

<para>对于YUM的配置，其中软件源的配置是非常重要的一部分。YUM关于源的配置在<literal>/etc/yum.repos.d/</literal>目录中。该目录下的每一个文件针对一个软件库，像镜像等的设置都存放在对应软件库文件中。</para>
<para>如果需要禁用某个软件库，有两种方式，一种是删除对应的库配置文件或重命名为其它扩展名。也可以将其中的<literal>enabled</literal>配置项设为<literal>0</literal>。通过<literal>enabled</literal>设置的一个好处是，可以通过yum的<literal>--eanblerepo</literal>参数临时重新启用。<literal>yum repolist enabled</literal>可以显示所有启用的软件库。</para>
<para>针对每一个软件库，YUM默认会从<link xlink:href="http://mirrors.fedoraproject.org"/>下载一份镜像列表，然后随机地选择从哪一个镜像下载。这样有时效率并不高，因为各个源的访问速率可能会相差很大。可以通过对源进行相应的配置，让YUM优先选择一些源。</para>
<para>比如将fedora和fedora-updates这两个软件库的镜像设置为优先使用网易的镜像，可以在<literal>/etc/yum.repos.d/fedora.repo</literal>和<literal>fedora-updates.repo</literal>文件中添加<literal>failovermethod</literal>及<literal>baseurl</literal>设置：</para>
<screen>failovermethod=priority
baseurl=http://mirrors.163.com/fedora/updates/$releasever/$basearch/</screen>
<para>另外，也可以安装<literal>yum-plugin-fastestmirror</literal>包，让yum自动选择最快的镜像。</para>
</sect1>
<sect1><title>RPM</title>

<para>通过对yum的介绍，可以看到yum已经基本上可以完成软件管理的功能，一般可以不再直接使用rpm命令了，这里只列出几个yum无法完成的功能：</para>
<variablelist>
<varlistentry><term><literal>rpm -ql pkg-name</literal></term>
<listitem><para>显示软件包中包含的所有文件</para></listitem>
</varlistentry>
<varlistentry><term><literal>rpm -ql -p path/to/rpm</literal></term>
<listitem><para>列出一个rpm包中的所有文件</para></listitem>
</varlistentry>
</variablelist>
<para>实际上，yum-utils中的repoquery可以用来完成这一功能。</para>
</sect1>
</appendix>

<!--
<index><title>索引</title></index>
-->

</book>

<!-- vim: set ft=docbk fdm=syntax : -->
